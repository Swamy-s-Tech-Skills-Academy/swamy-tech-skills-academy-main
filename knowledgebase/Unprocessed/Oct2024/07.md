# Caching

## Q1

> I want to implement Caching to store the Token which was received from TokenService. As this token is machine to machine. I am assuming that it will save time during load. Also, I am thinking of using In Memory Caching from .net C#. Please advise

Implementing in-memory caching to store tokens received from a token service is a great approach to optimize your application, especially for machine-to-machine communication. This will help reduce redundant requests to the token service, thereby saving time and resources during high loads.

Below is a detailed guide on how to implement **In-Memory Caching** for a machine-to-machine token in .NET C# using **MemoryCache** from `Microsoft.Extensions.Caching.Memory`.

### Steps for Implementing In-Memory Caching for Token

#### 1. **Install Required Package**

Ensure you have the `Microsoft.Extensions.Caching.Memory` package installed. You can install it via NuGet:

```bash
dotnet add package Microsoft.Extensions.Caching.Memory
```

#### 2. **Define the `ITokenService` Interface**

This interface will be used in your application to abstract the logic of fetching and caching the token.

```csharp
public interface ITokenService
{
    Task<string> GetTokenAsync();
}
```

#### 3. **Create the `TokenService` Class with In-Memory Caching**

Here, the `TokenService` class will fetch the token from the token service, cache it in memory, and return the cached token on subsequent requests until it expires.

```csharp
using Microsoft.Extensions.Caching.Memory;
using System.Net.Http;
using System.Text.Json;
using System.Threading.Tasks;

public class TokenService : ITokenService
{
    private readonly HttpClient _httpClient;
    private readonly IMemoryCache _memoryCache;
    private readonly string _tokenCacheKey = "cached_token";
    private readonly TimeSpan _tokenExpiryBuffer = TimeSpan.FromMinutes(5); // Buffer before token expiry

    public TokenService(HttpClient httpClient, IMemoryCache memoryCache)
    {
        _httpClient = httpClient;
        _memoryCache = memoryCache;
    }

    public async Task<string> GetTokenAsync()
    {
        // Check if the token is already cached
        if (_memoryCache.TryGetValue(_tokenCacheKey, out string cachedToken))
        {
            return cachedToken; // Return the cached token
        }

        // Token is not cached, so fetch a new token
        var token = await FetchTokenFromServiceAsync();

        // Cache the token with an expiration time based on the token's expiry minus buffer
        var tokenExpiryTime = GetTokenExpiryTime(token) - _tokenExpiryBuffer;
        _memoryCache.Set(_tokenCacheKey, token, tokenExpiryTime);

        return token;
    }

    private async Task<string> FetchTokenFromServiceAsync()
    {
        // Replace with actual token service URL and request logic
        var response = await _httpClient.PostAsync("https://token-service-url.com/token", new StringContent(""));

        if (!response.IsSuccessStatusCode)
        {
            throw new HttpRequestException("Failed to retrieve token from token service");
        }

        var content = await response.Content.ReadAsStringAsync();
        var tokenResponse = JsonSerializer.Deserialize<TokenResponse>(content);

        return tokenResponse?.AccessToken ?? throw new InvalidOperationException("Token response is null");
    }

    private TimeSpan GetTokenExpiryTime(string token)
    {
        // Parse the token to get the expiry time (JWT tokens often have an expiry field)
        // This is a placeholder; you can modify it based on the actual token structure.
        var tokenResponse = JsonSerializer.Deserialize<TokenResponse>(token);
        return TimeSpan.FromSeconds(tokenResponse.ExpiresIn);
    }
}

public class TokenResponse
{
    public string AccessToken { get; set; }
    public int ExpiresIn { get; set; } // Token validity duration in seconds
}
```

#### 4. **Register Services in `Program.cs` or `Startup.cs`**

You need to register both `HttpClient` and `MemoryCache` in the dependency injection container.

```csharp
using Microsoft.Extensions.Caching.Memory;

var builder = WebApplication.CreateBuilder(args);

// Register the TokenService with MemoryCache
builder.Services.AddHttpClient<ITokenService, TokenService>();
builder.Services.AddMemoryCache();

var app = builder.Build();

app.MapControllers();
app.Run();
```

#### 5. **Use `TokenService` in Your Application**

You can inject the `ITokenService` wherever you need to retrieve the token, like in your controller or any service.

Example usage in a Controller:

```csharp
[ApiController]
[Route("api/[controller]")]
public class ExternalServiceController : ControllerBase
{
    private readonly ITokenService _tokenService;

    public ExternalServiceController(ITokenService tokenService)
    {
        _tokenService = tokenService;
    }

    [HttpGet("external-data")]
    public async Task<IActionResult> GetExternalData()
    {
        // Retrieve the cached or fresh token
        var token = await _tokenService.GetTokenAsync();

        // Use the token to call an external API
        // You can create a method that makes an external API call with the token
        return Ok(new { Token = token });
    }
}
```

---

### Benefits of In-Memory Caching

- **Performance:** Caching the token reduces the need for multiple requests to the token service, improving performance during high-load scenarios.
- **Efficiency:** In-memory caching is lightweight and fast. You avoid unnecessary network calls when the token is already cached.
- **Token Expiration Handling:** By caching tokens with a calculated expiration time minus a buffer, you ensure that your application fetches a new token before the cached token expires.

### Expanding to Distributed Caching (Optional)

If your application is distributed across multiple instances, consider using a **distributed cache** (like Redis or SQL Server) instead of in-memory caching to share the token across all instances. Here's a simple guide:

1. **Install Redis distributed caching package:**

   ```bash
   dotnet add package Microsoft.Extensions.Caching.StackExchangeRedis
   ```

2. **Configure Redis in `Program.cs`:**

   ```csharp
   builder.Services.AddStackExchangeRedisCache(options =>
   {
       options.Configuration = "localhost:6379";  // Replace with actual Redis connection string
   });
   ```

3. **Replace `IMemoryCache` with `IDistributedCache`:**
   In your `TokenService`, switch from `IMemoryCache` to `IDistributedCache`, and use appropriate serialization/deserialization for storing tokens in Redis or any other distributed cache.

---

### Final Thoughts

- Using in-memory caching for tokens is an excellent optimization, especially for machine-to-machine tokens that don't need to be refreshed frequently.
- The **MemoryCache** in .NET is simple to use, and it integrates well with the dependency injection system, making it easy to manage token caching.
- If your application scales horizontally (multiple instances), consider using a distributed caching mechanism like Redis.

This approach will ensure that token requests are handled efficiently, improving the performance of your application. Let me know if you need help with additional configurations or specific extensions for distributed caching!

## Q2

> Cross cutting concern

Yes, caching can be implemented as a cross-cutting concern, and it’s a common practice in enterprise applications. Cross-cutting concerns like caching, logging, or security are typically abstracted into separate services so they can be reused across different layers or modules in a clean, decoupled manner.

### Overview of Cross-Cutting Caching

In this context, **caching** is a mechanism that is applied across various application layers (especially in the application and infrastructure layers) but is managed centrally so that it doesn't pollute the business logic. By encapsulating the caching logic, the code you shared can be reused throughout the application to store, retrieve, and clear cache items in a clean and organized way.

### Code Improvement and Articulation

Here's how your caching class can be articulated to better suit the cross-cutting concern:

```csharp
public class Cache : ICache
{
    private readonly IMemoryCache _memoryCache;
    private static readonly object _locker = new();
    private static readonly HashSet<string> _usedKeys = new();

    public Cache(IMemoryCache memoryCache)
    {
        _memoryCache = memoryCache;
    }

    #region Cache Management

    // Clears specific cache entry for artists (example)
    public void ClearArtists()
    {
        Clear("ArtistCacheKey");  // You can use a constant or variable here
    }

    // Clears entire cache
    public void ClearAll()
    {
        lock (_locker)
        {
            foreach (var usedKey in _usedKeys)
            {
                _memoryCache.Remove(usedKey);
            }
            _usedKeys.Clear();
        }
    }

    #endregion

    #region Cache Helpers

    // Clears single cache entry
    private void Clear(string key)
    {
        lock (_locker)
        {
            _memoryCache.Remove(key);
            _usedKeys.Remove(key);
        }
    }

    // Add to cache with expiration
    public void Add(string key, object value, TimeSpan expiration)
    {
        lock (_locker)
        {
            _memoryCache.Set(key, value, new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = expiration
            });
            _usedKeys.Add(key);
        }
    }

    // Retrieve cache item
    public T Get<T>(string key)
    {
        return _memoryCache.TryGetValue(key, out T value) ? value : default;
    }

    // Checks if an item exists in the cache
    public bool Exists(string key)
    {
        return _memoryCache.TryGetValue(key, out _);
    }

    #endregion
}
```

### Explanation of Key Features:

1. **Thread-Safe Operations**: A `lock` mechanism ensures that the cache operations are thread-safe, especially when multiple threads might be trying to add or remove cache entries simultaneously.
2. **Cache Clearing**: The class provides methods to clear a single cache item (e.g., artist data) or all cache items stored via the `Cache` class.
3. **Expiration**: The `Add` method supports an absolute expiration policy using `TimeSpan`.
4. **Retrieve and Check**: Added `Get` and `Exists` methods to retrieve cached items and check for their existence.
5. **UsedKeys Management**: This tracks keys that were added to the cache for easier removal later.

### Where to Place the Caching Code in a Clean Architecture

In a clean architecture, caching would typically sit in the **infrastructure layer** because it's a low-level concern about how data is stored or retrieved. However, the usage of the cache (e.g., adding or retrieving data) would be called from the **application layer**.

Here's how you can structure it:

#### 1. **Domain Layer**:

- The **domain layer** should remain unaware of caching. It's purely focused on the core business logic and entities, so no caching logic should exist here.

#### 2. **Application Layer**:

- This layer contains **services**, **use cases**, and **business logic**.
- If you want to use caching here, you could inject your `ICache` interface into the services where caching is needed.
- Example use case: If you're fetching data from an external API or database that doesn't change often (like artist data), you can cache it here to optimize performance.

```csharp
public class ArtistService
{
    private readonly ICache _cache;
    private readonly IArtistRepository _artistRepository;

    public ArtistService(ICache cache, IArtistRepository artistRepository)
    {
        _cache = cache;
        _artistRepository = artistRepository;
    }

    public async Task<Artist> GetArtistAsync(int artistId)
    {
        var cacheKey = $"Artist_{artistId}";

        if (_cache.Exists(cacheKey))
        {
            return _cache.Get<Artist>(cacheKey);  // Retrieve from cache
        }

        // Fetch from repository if not in cache
        var artist = await _artistRepository.GetArtistByIdAsync(artistId);

        if (artist != null)
        {
            _cache.Add(cacheKey, artist, TimeSpan.FromHours(1));  // Cache for 1 hour
        }

        return artist;
    }
}
```

#### 3. **Infrastructure Layer**:

- The `Cache` class and its implementation should be placed in the **infrastructure** layer.
- The infrastructure layer deals with external systems (databases, external services, etc.). In-memory caching is considered part of this because it's responsible for managing data storage in memory.

#### 4. **SharedKernel (Optional)**:

- If you have caching logic that is used across multiple bounded contexts, you might choose to place the `ICache` interface in the **SharedKernel**.
- The actual implementation (`Cache` class) can remain in the infrastructure layer, but the interface (`ICache`) can be shared across projects via the **SharedKernel**.

### Example Folder Structure:

```
Solution.sln
├── Solution.Domain              // Domain Layer (Entities, Interfaces)
├── Solution.Application         // Application Layer (Services, Use Cases, DTOs)
│   └── Services
│       └── ArtistService.cs      // Uses Caching
├── Solution.Infrastructure      // Infrastructure Layer (Data Access, External APIs, Cache)
│   └── Caching
│       └── Cache.cs              // Implementation of ICache
├── Solution.SharedKernel        // Shared Kernel (Common utilities, Value Objects)
│   └── Caching
│       └── ICache.cs             // Interface for Caching
└── Solution.WebAPI              // Presentation Layer (Controllers, API)
```

### Dependency Injection in `Program.cs`

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add caching and services
builder.Services.AddMemoryCache();
builder.Services.AddSingleton<ICache, Cache>();  // Cache implementation

builder.Services.AddScoped<IArtistService, ArtistService>();  // Example service
```

### Conclusion

By creating a caching service as a cross-cutting concern, you can decouple the caching logic from your business logic, making it easier to maintain and apply across your application. Here's a quick summary of the key points:

1. **Cache Interface and Implementation**: The `Cache` class encapsulates caching logic (adding, retrieving, clearing cache entries).
2. **Cross-Cutting Concern**: Cache should reside in the infrastructure layer but be accessed from the application layer.
3. **Clean Architecture**: The cache logic remains in the infrastructure layer, but caching operations (e.g., checking cache before hitting a repository or API) are performed in the application layer.

This approach enhances modularity and performance while keeping caching as a reusable, well-encapsulated concern across the application.

## Q3

> In future others can also use the caching. Let's keep it generic. Just want to let you know that currently only Token Service is using.

If the caching will be expanded for future use by other services, it makes sense to implement a **generic caching mechanism** that can support multiple use cases while keeping it flexible. Here’s a more **generic cache implementation** while keeping the current focus on the **Token Service** as the first user.

### Updated `Cache` Class (Generic):

```csharp
public class Cache : ICache
{
    private readonly IMemoryCache _memoryCache;
    private static readonly object _locker = new();
    private static readonly HashSet<string> _usedKeys = new();

    public Cache(IMemoryCache memoryCache)
    {
        _memoryCache = memoryCache;
    }

    // Get an item from the cache
    public T Get<T>(string key)
    {
        lock (_locker)
        {
            return _memoryCache.TryGetValue(key, out T value) ? value : default;
        }
    }

    // Add or update an item in the cache with expiration
    public void Add<T>(string key, T value, TimeSpan expiration)
    {
        lock (_locker)
        {
            _memoryCache.Set(key, value, new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = expiration
            });

            _usedKeys.Add(key);
        }
    }

    // Remove an item from the cache
    public void Remove(string key)
    {
        lock (_locker)
        {
            _memoryCache.Remove(key);
            _usedKeys.Remove(key);
        }
    }

    // Clear the entire cache
    public void Clear()
    {
        lock (_locker)
        {
            foreach (var key in _usedKeys)
            {
                _memoryCache.Remove(key);
            }
            _usedKeys.Clear();
        }
    }

    // Check if an item exists in the cache
    public bool Exists(string key)
    {
        return _memoryCache.TryGetValue(key, out _);
    }
}
```

### Key Features of the Generic Cache Class:

- **Generic Method Support**: The `Get<T>` and `Add<T>` methods support caching of different data types, not just tokens.
- **Thread-Safety**: The `lock` ensures safe access to the cache.
- **Cache Management**: It manages cached items using a `HashSet` of used keys for easy cleanup.
- **Flexible Expiration**: You can specify different expiration times for different cached items.

---

### Token Service Implementation Using Generic Cache

For the **Token Service**, you can still use this generic cache to store the token:

```csharp
public class TokenService
{
    private readonly ICache _cache;
    private readonly ITokenProvider _tokenProvider;  // Token provider logic (external API)
    private static readonly string TokenCacheKey = "MachineToken";

    public TokenService(ICache cache, ITokenProvider tokenProvider)
    {
        _cache = cache;
        _tokenProvider = tokenProvider;
    }

    public string GetToken()
    {
        // Check if the token is already cached
        if (_cache.Exists(TokenCacheKey))
        {
            return _cache.Get<string>(TokenCacheKey);
        }

        // If not, request a new token from the Token Provider (e.g., external API)
        var token = _tokenProvider.RequestToken();

        // Cache the token for future requests (assuming the token has a 1-hour expiration)
        _cache.Add(TokenCacheKey, token, TimeSpan.FromHours(1));

        return token;
    }

    // Clear the token if needed
    public void ClearToken()
    {
        _cache.Remove(TokenCacheKey);
    }
}
```

### Explanation:

- **Token Retrieval**: First, the method checks if the token is already cached. If it exists, it retrieves it from the cache. Otherwise, it fetches a new token from the external provider and stores it in the cache.
- **Expiration**: The token is cached with an expiration time, typically matching the token’s lifetime (e.g., 1 hour).
- **Generic Usage**: This service can easily be extended for other use cases by adding more keys for other services.

---

### Where to Place This Code:

1. **Cache Class (`Cache`)**: This is a **cross-cutting concern**, so place it in a shared or infrastructure layer accessible to other services. Typically, this would go under:

   - **Solution.Infrastructure**
   - **Solution.SharedKernel** (if this is a more general utility across projects)

2. **Token Service**: The **Token Service** should reside in the **Application Layer** as it deals with token retrieval, caching, and business logic.

3. **ICache Interface**: Define the interface for caching so that it's flexible for future changes:

   ```csharp
   public interface ICache
   {
       T Get<T>(string key);
       void Add<T>(string key, T value, TimeSpan expiration);
       void Remove(string key);
       void Clear();
       bool Exists(string key);
   }
   ```

### Summary:

- You've now got a **generic cache implementation** that supports multiple services, including the **Token Service**.
- For the **Token Service**, you can use this generic cache to reduce unnecessary token requests, improving performance.
- This cache can easily be extended for other types of data in the future, making it a reusable cross-cutting concern.

Let me know if you'd like further refinement or testing advice!

Given your previous design, where the `ITokenService` interface resides inside the **Domain** layer, and `TokenService` is inside the **Infrastructure** layer, it’s important to keep the caching logic at a level where it doesn't violate the principles of Clean Architecture. The `TokenService` would interact with the caching layer, and the `Cache` service should be injected wherever required, keeping the system flexible and generic for future usage.

Here's how you can structure the caching logic without affecting the separation of concerns:

### 1. **Domain Layer:**

In the **Domain** layer, `ITokenService` should remain untouched, as it simply defines the contract.

#### `ITokenService.cs` (Interface remains the same)

```csharp
namespace Solution.Domain.Interfaces.AuthToken
{
    public interface ITokenService
    {
        Task<string> GetTokenAsync();
    }
}
```

### 2. **Infrastructure Layer:**

In the **Infrastructure** layer, the `TokenService` will now leverage the `ICache` interface to store and retrieve tokens.

#### `TokenService.cs` (Modify the existing service to use caching)

```csharp
using Solution.Domain.Interfaces.AuthToken;
using Solution.SharedKernel.Interfaces;  // For ICache
using System;
using System.Net.Http;
using System.Threading.Tasks;

namespace Solution.Infrastructure.Services.AuthToken
{
    public class TokenService : ITokenService
    {
        private readonly HttpClient _httpClient;
        private readonly ICache _cache;
        private static readonly string TokenCacheKey = "AuthToken";
        private static readonly TimeSpan TokenExpiration = TimeSpan.FromMinutes(59); // 59 minutes to handle expiration buffer

        public TokenService(HttpClient httpClient, ICache cache)
        {
            _httpClient = httpClient;
            _cache = cache;
        }

        public async Task<string> GetTokenAsync()
        {
            // Check if the token exists in the cache
            if (_cache.TryGetValue<string>(TokenCacheKey, out var cachedToken))
            {
                return cachedToken;
            }

            // Simulating token fetch from external Token Service
            var newToken = await FetchTokenFromServiceAsync();

            // Store the token in cache for future use
            _cache.Set(TokenCacheKey, newToken, DateTimeOffset.UtcNow.Add(TokenExpiration));

            return newToken;
        }

        private async Task<string> FetchTokenFromServiceAsync()
        {
            // Logic to call external token service and retrieve token
            // This is a placeholder implementation
            HttpResponseMessage response = await _httpClient.GetAsync("https://token-service-url");
            response.EnsureSuccessStatusCode();

            string token = await response.Content.ReadAsStringAsync();
            return token;
        }
    }
}
```

### 3. **Shared Kernel:**

In the **Shared Kernel**, you'll define your `ICache` and `Cache` implementation, which will be reusable across different services in the future.

#### `ICache.cs` (Interface remains in SharedKernel)

```csharp
namespace Solution.SharedKernel.Interfaces
{
    public interface ICache
    {
        T Get<T>(string key);
        void Set<T>(string key, T value, DateTimeOffset expiration);
        bool TryGetValue<T>(string key, out T value);
        void Clear(string key);
        void ClearAll();
    }
}
```

#### `Cache.cs` (Generic Cache Service in SharedKernel)

```csharp
using Microsoft.Extensions.Caching.Memory;
using Solution.SharedKernel.Interfaces;
using System;
using System.Collections.Generic;

namespace Solution.SharedKernel.Services
{
    public class Cache : ICache
    {
        private readonly IMemoryCache _memoryCache;
        private static readonly object locker = new();
        private readonly HashSet<string> _usedKeys = new();

        public Cache(IMemoryCache memoryCache)
        {
            _memoryCache = memoryCache;
        }

        public T Get<T>(string key)
        {
            _memoryCache.TryGetValue(key, out T value);
            return value;
        }

        public void Set<T>(string key, T value, DateTimeOffset expiration)
        {
            lock (locker)
            {
                _memoryCache.Set(key, value, new MemoryCacheEntryOptions
                {
                    AbsoluteExpiration = expiration
                });
                _usedKeys.Add(key);
            }
        }

        public bool TryGetValue<T>(string key, out T value)
        {
            return _memoryCache.TryGetValue(key, out value);
        }

        public void Clear(string key)
        {
            lock (locker)
            {
                _memoryCache.Remove(key);
                _usedKeys.Remove(key);
            }
        }

        public void ClearAll()
        {
            lock (locker)
            {
                foreach (var key in _usedKeys)
                {
                    _memoryCache.Remove(key);
                }

                _usedKeys.Clear();
            }
        }
    }
}
```

### 4. **Registering Caching in `Startup` or `Program.cs`:**

Ensure that you register both the `ICache` and `ITokenService` in the **Dependency Injection (DI) container**.

#### In `Program.cs` (for .NET 8)

```csharp
using Solution.Infrastructure.Services.AuthToken;
using Solution.SharedKernel.Interfaces;
using Solution.SharedKernel.Services;

var builder = WebApplication.CreateBuilder(args);

// Register IMemoryCache (from Microsoft.Extensions.Caching.Memory)
builder.Services.AddMemoryCache();

// Register ICache and TokenService
builder.Services.AddScoped<ICache, Cache>();
builder.Services.AddScoped<ITokenService, TokenService>();

var app = builder.Build();

// Your middleware, routing, etc.

app.Run();
```

### Benefits of This Design:

1. **Reusability:** The `ICache` and its implementation are generic enough to be used in other services in the future, beyond just the `TokenService`.
2. **Separation of Concerns:** The caching logic is separate from the `TokenService`, which adheres to Clean Architecture principles. This keeps the domain and infrastructure layers focused on their respective responsibilities.
3. **Extensibility:** Future services that require caching can directly depend on `ICache` and be injected into any service.
4. **Flexibility:** You can easily swap out the in-memory cache for a distributed cache (e.g., Redis) in the future, without altering the rest of the application.

Let me know if you need further refinements!

Great! Since you have separate `ServiceCollectionExtension` classes in both **Application** and **Infrastructure** layers, it aligns well with the principles of **Clean Architecture**. This structure allows you to keep each layer independent, with the Application layer orchestrating logic and the Infrastructure layer dealing with external services like caching and database access.

To accommodate caching and the `TokenService` registration, you'll add the appropriate configurations inside the **Infrastructure layer** `ServiceCollectionExtension`. This will ensure that caching and token services are properly registered where they belong.

### 1. **Infrastructure Layer Service Collection Extension**

Inside the **Infrastructure layer**, you’ll extend the `IServiceCollection` to include the necessary services like caching (`ICache` and `TokenService`).

#### `ServiceCollectionExtension.cs` in the **Infrastructure** Layer

```csharp
using Microsoft.Extensions.DependencyInjection;
using Solution.Infrastructure.Services.AuthToken;   // TokenService
using Solution.SharedKernel.Interfaces;           // ICache
using Solution.SharedKernel.Services;             // Cache

namespace Solution.Infrastructure
{
    public static class ServiceCollectionExtension
    {
        public static void AddInfrastructureServices(this IServiceCollection services)
        {
            // Register the IMemoryCache from Microsoft.Extensions.Caching.Memory
            services.AddMemoryCache();

            // Register the ICache service from Shared Kernel
            services.AddScoped<ICache, Cache>();

            // Register TokenService to be used by the application
            services.AddScoped<ITokenService, TokenService>();

            // Add any other infrastructure-related services here
        }
    }
}
```

### 2. **Application Layer Service Collection Extension**

In the **Application layer**, you can register other services that the application might need. You can skip the caching logic here since it belongs to the infrastructure.

#### `ServiceCollectionExtension.cs` in the **Application** Layer

```csharp
using Microsoft.Extensions.DependencyInjection;

namespace Solution.Application
{
    public static class ServiceCollectionExtension
    {
        public static void AddApplicationServices(this IServiceCollection services)
        {
            // Register application-specific services here
            // Example: services.AddScoped<IYourService, YourService>();

            // Any application-wide policies, factories, or handlers go here
        }
    }
}
```

### 3. **Wiring it Up in `Program.cs`**

Finally, you need to ensure that both your **Application** and **Infrastructure** services are wired up in `Program.cs` (or `Startup.cs` if applicable). You can call both extension methods in the startup configuration.

#### `Program.cs` (for .NET 8)

```csharp
using Solution.Application;
using Solution.Infrastructure;

var builder = WebApplication.CreateBuilder(args);

// Add services from the Application layer
builder.Services.AddApplicationServices();

// Add services from the Infrastructure layer
builder.Services.AddInfrastructureServices();

var app = builder.Build();

// Configure the middleware pipeline and run the application
app.Run();
```

### Summary:

- **Infrastructure Layer:** Handles registration of `ICache`, `TokenService`, and any other infrastructure-related services.
- **Application Layer:** Registers application-specific services like use cases, application logic, and possibly service orchestration.
- **Program.cs:** Both `AddApplicationServices` and `AddInfrastructureServices` are called, ensuring that all necessary services are available across layers.

This approach keeps your **ServiceCollection extensions** modular, ensuring a clean separation of concerns between layers, while also allowing you to expand easily as your application grows.

Here's the updated folder structure with the caching implementation added, as per your requirements:

```
Solution.sln
├── Solution.Domain              // Domain Layer (Entities, Interfaces)
│   └── Interfaces
│       └── AuthToken
│           └── ITokenService.cs  // Interface for token service
├── Solution.Application         // Application Layer (Services, Use Cases, DTOs)
│   └── Services
│       └── AuthToken
│           └── TokenService.cs   // Uses Caching
│   └── Extensions
│       └── ServiceCollectionExtensions.cs  // Registers application services
├── Solution.Infrastructure      // Infrastructure Layer (Data Access, External APIs, Cache)
│   └── Services
│       └── AuthToken
│           └── TokenService.cs   // Implements ITokenService and uses Cache
│   └── Caching
│       └── Cache.cs              // Implementation of ICache
│   └── Extensions
│       └── ServiceCollectionExtensions.cs  // Registers infrastructure services (Cache, Token Service, etc.)
├── Solution.SharedKernel        // Shared Kernel (Common utilities, Value Objects)
│   └── Caching
│       └── ICache.cs             // Interface for Caching
└── Solution.WebAPI              // Presentation Layer (Controllers, API)
    └── Controllers
        └── TokenController.cs    // API Controller for Token Service
```

### Breakdown of Changes:

1. **Domain Layer:**
   - `Interfaces/AuthToken/ITokenService.cs`: The `ITokenService` interface defines the contract for the token service.
2. **Application Layer:**

   - `Services/AuthToken/TokenService.cs`: Uses caching via the `ICache` interface in the `TokenService` logic.
   - `Extensions/ServiceCollectionExtensions.cs`: Contains extension methods to register application layer services.

3. **Infrastructure Layer:**

   - `Services/AuthToken/TokenService.cs`: Implementation of the `ITokenService` interface, using caching through `ICache`.
   - `Caching/Cache.cs`: Implementation of the `ICache` interface for managing caching operations.
   - `Extensions/ServiceCollectionExtensions.cs`: Adds infrastructure services, such as caching and token service registration.

4. **SharedKernel:**

   - `Caching/ICache.cs`: Defines the interface for caching, used across various layers.

5. **WebAPI:**
   - `Controllers/TokenController.cs`: The controller to expose token-related operations via API.

This structure keeps the code modular, reusable, and compliant with the principles of Clean Architecture. Let me know if you'd like to adjust anything further!

## Q4

> Why are we defining the ICache inside SharedKernel?
> Why do we have TokenService inside Application Layer?

Great questions! Let me explain the rationale behind these design choices and suggest some potential improvements.

### 1. **Why are we defining `ICache` inside the Shared Kernel?**

The **Shared Kernel** is intended for any common functionality or interfaces that multiple layers of the application might use. The caching logic, in particular, is often a cross-cutting concern, meaning that it could be utilized by services in multiple layers (such as the Application and Infrastructure layers). This is why placing the `ICache` interface in the **Shared Kernel** makes sense:

- **Reuse across layers:** Both the Application and Infrastructure layers (and potentially others) may need to use caching, and centralizing the caching interface in the Shared Kernel promotes reuse and consistency.
- **Independence from specific implementations:** The Shared Kernel ensures the rest of your code remains decoupled from the actual caching mechanism (like in-memory or distributed caching). Any caching implementation can be plugged in later without modifying the consumers.

However, if your `ICache` is only intended for internal use by a specific layer or service, and you don't anticipate it being reused elsewhere, you could place it within the **Infrastructure** layer. But placing it in the Shared Kernel gives you flexibility for the future.

### 2. **Why is `TokenService` inside the Application Layer?**

Placing the `TokenService` inside the **Application Layer** in a Clean Architecture setup is typically done because the **Application Layer** is responsible for business logic, orchestrating use cases, and interacting with domain entities or services.

Here's why `TokenService` might belong in the Application Layer:

- **Use case orchestration:** If the `TokenService` involves more than just calling an external service (e.g., business logic related to token caching, refreshing, or security rules), it fits into the Application layer as it handles core business operations.
- **Abstraction over external systems:** The Application layer should interact with external services like token providers through well-defined abstractions (e.g., `ITokenService`). This ensures your core application logic is decoupled from external dependencies.

However, if the `TokenService` is purely about interacting with external APIs (e.g., a token provider service) and doesn't contain significant business logic, it might be better suited for the **Infrastructure Layer**.

### Suggested Changes to the Structure

If you see that `TokenService` is mainly about external API interaction without complex business rules, we can move it entirely to the **Infrastructure Layer**.

### Updated Structure with `TokenService` in Infrastructure Layer

```
Solution.sln
├── Solution.Domain              // Domain Layer (Entities, Interfaces)
│   └── Interfaces
│       └── AuthToken
│           └── ITokenService.cs  // Interface for token service
├── Solution.Application         // Application Layer (Use Cases, DTOs)
│   └── Services                 // Core business logic services
│       └── ArtistService.cs      // Example service that uses Caching
│   └── Extensions
│       └── ServiceCollectionExtensions.cs  // Registers application services
├── Solution.Infrastructure      // Infrastructure Layer (Data Access, External APIs, Cache)
│   └── Services
│       └── AuthToken
│           └── TokenService.cs   // Implements ITokenService, uses Cache
│   └── Caching
│       └── Cache.cs              // Implementation of ICache
│   └── Extensions
│       └── ServiceCollectionExtensions.cs  // Registers infrastructure services
├── Solution.SharedKernel        // Shared Kernel (Common utilities, Value Objects)
│   └── Caching
│       └── ICache.cs             // Interface for Caching (Optional, can move to Infrastructure)
└── Solution.WebAPI              // Presentation Layer (Controllers, API)
    └── Controllers
        └── TokenController.cs    // API Controller for Token Service
```

### Explanation:

1. **Domain Layer:**

   - No change here, the `ITokenService` interface remains part of the domain logic.

2. **Application Layer:**

   - If your `TokenService` doesn't have complex logic beyond external API calls and caching, you can exclude it from here.
   - Keep only services that involve core business use cases here.

3. **Infrastructure Layer:**

   - The `TokenService` belongs here since it's interacting with an external token provider.
   - It uses caching (from the `ICache` implementation).
   - This layer now handles both the caching logic and token service logic, as it's mainly external dependency management.

4. **Shared Kernel:**
   - `ICache.cs` remains in the Shared Kernel if caching could be used across multiple layers (Application, Infrastructure, etc.). However, if caching is only needed within the Infrastructure Layer, you can move it there as well.

### Conclusion:

- **When to keep `ICache` in Shared Kernel:** If caching will be used in multiple layers (such as in Application or Domain layers for other services in the future), keeping `ICache` in the Shared Kernel is a good design choice.
- **When to keep `TokenService` in Infrastructure Layer:** If the `TokenService` mainly involves API calls and caching with minimal business logic, placing it in the Infrastructure layer keeps your architecture clean.

Would you like me to adjust the code or structure based on this explanation?

## Q6

> Explain

Certainly! Let's break down the `CacheInMemory` class, which implements the `ICache` interface. This class is responsible for managing in-memory caching in your application. Here’s an explanation of each part:

### Class Declaration

```csharp
internal class CacheInMemory : ICache
```

- **`internal`**: The class is accessible only within the same assembly. This is a common practice for classes that are implementation details and not part of the public API.
- **`CacheInMemory`**: The name of the class that indicates it provides an in-memory caching solution.
- **`ICache`**: This indicates that `CacheInMemory` implements the `ICache` interface, which defines the methods available for caching operations.

### Fields

```csharp
private readonly IMemoryCache _memoryCache;
private static readonly object locker = new();
private readonly HashSet<string> _usedKeys = [];
```

- **`IMemoryCache _memoryCache`**: An instance of `IMemoryCache`, provided through dependency injection, which is used to perform caching operations.
- **`static readonly object locker`**: A static object used for locking to ensure thread safety when modifying the cache.
- **`HashSet<string> _usedKeys`**: A collection to keep track of the keys that have been used for caching, allowing for easy clearing of specific entries or all entries in the cache.

### Constructor

```csharp
public CacheInMemory(IMemoryCache memoryCache)
{
    _memoryCache = memoryCache;
}
```

- The constructor takes an `IMemoryCache` instance as a parameter, which is assigned to the `_memoryCache` field. This allows the class to utilize the provided memory cache.

### Methods

1. **`Get<T>(string key)`**

   ```csharp
   public T? Get<T>(string key)
   {
       _memoryCache.TryGetValue(key, out T? value);
       return value;
   }
   ```

   - Attempts to retrieve a cached value by its key. If the key exists, the value is returned; otherwise, `null` is returned. The use of a generic type `T` allows flexibility in the type of cached objects.

2. **`Set<T>(string key, T value, DateTimeOffset expiration)`**

   ```csharp
   public void Set<T>(string key, T value, DateTimeOffset expiration)
   {
       lock (locker)
       {
           _memoryCache.Set(key, value, new MemoryCacheEntryOptions
           {
               AbsoluteExpiration = expiration
           });

           _usedKeys.Add(key);
       }
   }
   ```

   - This method stores a value in the cache with a specified expiration time. The use of `lock (locker)` ensures that only one thread can execute this code at a time, preventing race conditions. The key is added to the `_usedKeys` collection for future reference.

3. **`TryGetValue<T>(string key, out T? value)`**

   ```csharp
   public bool TryGetValue<T>(string key, out T? value)
   {
       return _memoryCache.TryGetValue(key, out value);
   }
   ```

   - Attempts to retrieve a value from the cache and returns a boolean indicating success. The retrieved value is returned via the `out` parameter.

4. **`Clear(string key)`**

   ```csharp
   public void Clear(string key)
   {
       lock (locker)
       {
           _memoryCache.Remove(key);
           _usedKeys.Remove(key);
       }
   }
   ```

   - Clears a specific cached entry identified by the key. The key is also removed from the `_usedKeys` collection.

5. **`ClearAll()`**

   ```csharp
   public void ClearAll()
   {
       lock (locker)
       {
           foreach (var key in _usedKeys)
           {
               _memoryCache.Remove(key);
           }

           _usedKeys.Clear();
       }
   }
   ```

   - This method clears all cached entries. It iterates through the `_usedKeys` collection, removing each key from the cache, and then clears the `_usedKeys` collection itself.

### Summary

The `CacheInMemory` class is a simple yet effective implementation of an in-memory caching solution. It encapsulates operations like adding, retrieving, and clearing cached items while ensuring thread safety through locking. The use of `HashSet` for tracking keys enables efficient cache management.

This class could be utilized throughout your application wherever caching is needed, enhancing performance by avoiding unnecessary calls to external services or databases, especially for frequently accessed data like tokens.
