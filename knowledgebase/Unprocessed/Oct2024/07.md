# Caching

## Q1

> I want to implement Caching to store the Token which was received from TokenService. As this token is machine to machine. I am assuming that it will save time during load. Also, I am thinking of using In Memory Caching from .net C#. Please advise

Implementing in-memory caching to store tokens received from a token service is a great approach to optimize your application, especially for machine-to-machine communication. This will help reduce redundant requests to the token service, thereby saving time and resources during high loads.

Below is a detailed guide on how to implement **In-Memory Caching** for a machine-to-machine token in .NET C# using **MemoryCache** from `Microsoft.Extensions.Caching.Memory`.

### Steps for Implementing In-Memory Caching for Token

#### 1. **Install Required Package**

Ensure you have the `Microsoft.Extensions.Caching.Memory` package installed. You can install it via NuGet:

```bash
dotnet add package Microsoft.Extensions.Caching.Memory
```

#### 2. **Define the `ITokenService` Interface**

This interface will be used in your application to abstract the logic of fetching and caching the token.

```csharp
public interface ITokenService
{
    Task<string> GetTokenAsync();
}
```

#### 3. **Create the `TokenService` Class with In-Memory Caching**

Here, the `TokenService` class will fetch the token from the token service, cache it in memory, and return the cached token on subsequent requests until it expires.

```csharp
using Microsoft.Extensions.Caching.Memory;
using System.Net.Http;
using System.Text.Json;
using System.Threading.Tasks;

public class TokenService : ITokenService
{
    private readonly HttpClient _httpClient;
    private readonly IMemoryCache _memoryCache;
    private readonly string _tokenCacheKey = "cached_token";
    private readonly TimeSpan _tokenExpiryBuffer = TimeSpan.FromMinutes(5); // Buffer before token expiry

    public TokenService(HttpClient httpClient, IMemoryCache memoryCache)
    {
        _httpClient = httpClient;
        _memoryCache = memoryCache;
    }

    public async Task<string> GetTokenAsync()
    {
        // Check if the token is already cached
        if (_memoryCache.TryGetValue(_tokenCacheKey, out string cachedToken))
        {
            return cachedToken; // Return the cached token
        }

        // Token is not cached, so fetch a new token
        var token = await FetchTokenFromServiceAsync();

        // Cache the token with an expiration time based on the token's expiry minus buffer
        var tokenExpiryTime = GetTokenExpiryTime(token) - _tokenExpiryBuffer;
        _memoryCache.Set(_tokenCacheKey, token, tokenExpiryTime);

        return token;
    }

    private async Task<string> FetchTokenFromServiceAsync()
    {
        // Replace with actual token service URL and request logic
        var response = await _httpClient.PostAsync("https://token-service-url.com/token", new StringContent(""));

        if (!response.IsSuccessStatusCode)
        {
            throw new HttpRequestException("Failed to retrieve token from token service");
        }

        var content = await response.Content.ReadAsStringAsync();
        var tokenResponse = JsonSerializer.Deserialize<TokenResponse>(content);

        return tokenResponse?.AccessToken ?? throw new InvalidOperationException("Token response is null");
    }

    private TimeSpan GetTokenExpiryTime(string token)
    {
        // Parse the token to get the expiry time (JWT tokens often have an expiry field)
        // This is a placeholder; you can modify it based on the actual token structure.
        var tokenResponse = JsonSerializer.Deserialize<TokenResponse>(token);
        return TimeSpan.FromSeconds(tokenResponse.ExpiresIn);
    }
}

public class TokenResponse
{
    public string AccessToken { get; set; }
    public int ExpiresIn { get; set; } // Token validity duration in seconds
}
```

#### 4. **Register Services in `Program.cs` or `Startup.cs`**

You need to register both `HttpClient` and `MemoryCache` in the dependency injection container.

```csharp
using Microsoft.Extensions.Caching.Memory;

var builder = WebApplication.CreateBuilder(args);

// Register the TokenService with MemoryCache
builder.Services.AddHttpClient<ITokenService, TokenService>();
builder.Services.AddMemoryCache();

var app = builder.Build();

app.MapControllers();
app.Run();
```

#### 5. **Use `TokenService` in Your Application**

You can inject the `ITokenService` wherever you need to retrieve the token, like in your controller or any service.

Example usage in a Controller:

```csharp
[ApiController]
[Route("api/[controller]")]
public class ExternalServiceController : ControllerBase
{
    private readonly ITokenService _tokenService;

    public ExternalServiceController(ITokenService tokenService)
    {
        _tokenService = tokenService;
    }

    [HttpGet("external-data")]
    public async Task<IActionResult> GetExternalData()
    {
        // Retrieve the cached or fresh token
        var token = await _tokenService.GetTokenAsync();

        // Use the token to call an external API
        // You can create a method that makes an external API call with the token
        return Ok(new { Token = token });
    }
}
```

---

### Benefits of In-Memory Caching

- **Performance:** Caching the token reduces the need for multiple requests to the token service, improving performance during high-load scenarios.
- **Efficiency:** In-memory caching is lightweight and fast. You avoid unnecessary network calls when the token is already cached.
- **Token Expiration Handling:** By caching tokens with a calculated expiration time minus a buffer, you ensure that your application fetches a new token before the cached token expires.

### Expanding to Distributed Caching (Optional)

If your application is distributed across multiple instances, consider using a **distributed cache** (like Redis or SQL Server) instead of in-memory caching to share the token across all instances. Here's a simple guide:

1. **Install Redis distributed caching package:**

   ```bash
   dotnet add package Microsoft.Extensions.Caching.StackExchangeRedis
   ```

2. **Configure Redis in `Program.cs`:**

   ```csharp
   builder.Services.AddStackExchangeRedisCache(options =>
   {
       options.Configuration = "localhost:6379";  // Replace with actual Redis connection string
   });
   ```

3. **Replace `IMemoryCache` with `IDistributedCache`:**
   In your `TokenService`, switch from `IMemoryCache` to `IDistributedCache`, and use appropriate serialization/deserialization for storing tokens in Redis or any other distributed cache.

---

### Final Thoughts

- Using in-memory caching for tokens is an excellent optimization, especially for machine-to-machine tokens that don't need to be refreshed frequently.
- The **MemoryCache** in .NET is simple to use, and it integrates well with the dependency injection system, making it easy to manage token caching.
- If your application scales horizontally (multiple instances), consider using a distributed caching mechanism like Redis.

This approach will ensure that token requests are handled efficiently, improving the performance of your application. Let me know if you need help with additional configurations or specific extensions for distributed caching!

## Q2

> Cross cutting concern

Yes, caching can be implemented as a cross-cutting concern, and itâ€™s a common practice in enterprise applications. Cross-cutting concerns like caching, logging, or security are typically abstracted into separate services so they can be reused across different layers or modules in a clean, decoupled manner.

### Overview of Cross-Cutting Caching

In this context, **caching** is a mechanism that is applied across various application layers (especially in the application and infrastructure layers) but is managed centrally so that it doesn't pollute the business logic. By encapsulating the caching logic, the code you shared can be reused throughout the application to store, retrieve, and clear cache items in a clean and organized way.

### Code Improvement and Articulation

Here's how your caching class can be articulated to better suit the cross-cutting concern:

```csharp
public class Cache : ICache
{
    private readonly IMemoryCache _memoryCache;
    private static readonly object _locker = new();
    private static readonly HashSet<string> _usedKeys = new();

    public Cache(IMemoryCache memoryCache)
    {
        _memoryCache = memoryCache;
    }

    #region Cache Management

    // Clears specific cache entry for artists (example)
    public void ClearArtists()
    {
        Clear("ArtistCacheKey");  // You can use a constant or variable here
    }

    // Clears entire cache
    public void ClearAll()
    {
        lock (_locker)
        {
            foreach (var usedKey in _usedKeys)
            {
                _memoryCache.Remove(usedKey);
            }
            _usedKeys.Clear();
        }
    }

    #endregion

    #region Cache Helpers

    // Clears single cache entry
    private void Clear(string key)
    {
        lock (_locker)
        {
            _memoryCache.Remove(key);
            _usedKeys.Remove(key);
        }
    }

    // Add to cache with expiration
    public void Add(string key, object value, TimeSpan expiration)
    {
        lock (_locker)
        {
            _memoryCache.Set(key, value, new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = expiration
            });
            _usedKeys.Add(key);
        }
    }

    // Retrieve cache item
    public T Get<T>(string key)
    {
        return _memoryCache.TryGetValue(key, out T value) ? value : default;
    }

    // Checks if an item exists in the cache
    public bool Exists(string key)
    {
        return _memoryCache.TryGetValue(key, out _);
    }

    #endregion
}
```

### Explanation of Key Features:

1. **Thread-Safe Operations**: A `lock` mechanism ensures that the cache operations are thread-safe, especially when multiple threads might be trying to add or remove cache entries simultaneously.
2. **Cache Clearing**: The class provides methods to clear a single cache item (e.g., artist data) or all cache items stored via the `Cache` class.
3. **Expiration**: The `Add` method supports an absolute expiration policy using `TimeSpan`.
4. **Retrieve and Check**: Added `Get` and `Exists` methods to retrieve cached items and check for their existence.
5. **UsedKeys Management**: This tracks keys that were added to the cache for easier removal later.

### Where to Place the Caching Code in a Clean Architecture

In a clean architecture, caching would typically sit in the **infrastructure layer** because it's a low-level concern about how data is stored or retrieved. However, the usage of the cache (e.g., adding or retrieving data) would be called from the **application layer**.

Here's how you can structure it:

#### 1. **Domain Layer**:

- The **domain layer** should remain unaware of caching. It's purely focused on the core business logic and entities, so no caching logic should exist here.

#### 2. **Application Layer**:

- This layer contains **services**, **use cases**, and **business logic**.
- If you want to use caching here, you could inject your `ICache` interface into the services where caching is needed.
- Example use case: If you're fetching data from an external API or database that doesn't change often (like artist data), you can cache it here to optimize performance.

```csharp
public class ArtistService
{
    private readonly ICache _cache;
    private readonly IArtistRepository _artistRepository;

    public ArtistService(ICache cache, IArtistRepository artistRepository)
    {
        _cache = cache;
        _artistRepository = artistRepository;
    }

    public async Task<Artist> GetArtistAsync(int artistId)
    {
        var cacheKey = $"Artist_{artistId}";

        if (_cache.Exists(cacheKey))
        {
            return _cache.Get<Artist>(cacheKey);  // Retrieve from cache
        }

        // Fetch from repository if not in cache
        var artist = await _artistRepository.GetArtistByIdAsync(artistId);

        if (artist != null)
        {
            _cache.Add(cacheKey, artist, TimeSpan.FromHours(1));  // Cache for 1 hour
        }

        return artist;
    }
}
```

#### 3. **Infrastructure Layer**:

- The `Cache` class and its implementation should be placed in the **infrastructure** layer.
- The infrastructure layer deals with external systems (databases, external services, etc.). In-memory caching is considered part of this because it's responsible for managing data storage in memory.

#### 4. **SharedKernel (Optional)**:

- If you have caching logic that is used across multiple bounded contexts, you might choose to place the `ICache` interface in the **SharedKernel**.
- The actual implementation (`Cache` class) can remain in the infrastructure layer, but the interface (`ICache`) can be shared across projects via the **SharedKernel**.

### Example Folder Structure:

```
Solution.sln
â”œâ”€â”€ Solution.Domain              // Domain Layer (Entities, Interfaces)
â”œâ”€â”€ Solution.Application         // Application Layer (Services, Use Cases, DTOs)
â”‚   â””â”€â”€ Services
â”‚       â””â”€â”€ ArtistService.cs      // Uses Caching
â”œâ”€â”€ Solution.Infrastructure      // Infrastructure Layer (Data Access, External APIs, Cache)
â”‚   â””â”€â”€ Caching
â”‚       â””â”€â”€ Cache.cs              // Implementation of ICache
â”œâ”€â”€ Solution.SharedKernel        // Shared Kernel (Common utilities, Value Objects)
â”‚   â””â”€â”€ Caching
â”‚       â””â”€â”€ ICache.cs             // Interface for Caching
â””â”€â”€ Solution.WebAPI              // Presentation Layer (Controllers, API)
```

### Dependency Injection in `Program.cs`

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add caching and services
builder.Services.AddMemoryCache();
builder.Services.AddSingleton<ICache, Cache>();  // Cache implementation

builder.Services.AddScoped<IArtistService, ArtistService>();  // Example service
```

### Conclusion

By creating a caching service as a cross-cutting concern, you can decouple the caching logic from your business logic, making it easier to maintain and apply across your application. Here's a quick summary of the key points:

1. **Cache Interface and Implementation**: The `Cache` class encapsulates caching logic (adding, retrieving, clearing cache entries).
2. **Cross-Cutting Concern**: Cache should reside in the infrastructure layer but be accessed from the application layer.
3. **Clean Architecture**: The cache logic remains in the infrastructure layer, but caching operations (e.g., checking cache before hitting a repository or API) are performed in the application layer.

This approach enhances modularity and performance while keeping caching as a reusable, well-encapsulated concern across the application.

## Q3
